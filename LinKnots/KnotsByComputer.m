(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)

BeginPackage["KnotsByComputer`"]

GetPdatabyTracking::usage =  "GetPdatabyTracking[], GetPdatabyTracking[PdataFileName] opens a window for input a knot (or link) and returns its P-data using an external program MouseTracking.exe. In case you specified the PL-data file name, the knot (ot link) digagram for the given PL-data will be appeared by right-bottom click in the window. In case with no data file, users can draw a knot (or link) on the window by mouse-tracking.(This mouse-tracking routine is based on that of SnaPea by J.Weeks.) You can change up-down of the crossings by left-botton click around the crossing, and also undo the tracking by Delete-key. P-data will be returned as an output when you close the window. This function generates a file MOUSETRACK.log, which has P-data (for file type) and PL-data of the input knot (or link) diagram, and PL-data file LastPLdata.pl."\

		

ShowKnotfromPdata::usage = "ShowKnotfromPdata[Pdata, s:7, (options...) ] calls an external program DrawKnot.exe which calculates the coordinates of points on the knot (or link) required for drawing. It plots the image of the knot (or link) for the given P-data. The second parameter 's' indicates the number of the side-faces. Options are taken to a graphix command of Mathematica, Show[], directly." \

 

ShowKnotFromFile::usage ="ShowKnotFromFile[PdataFileName] plots the image of nots (or links) for the P-data (for file type) given by a file. More than one P-data can be given through the file, and notice that EOF (or 555) needs to be in the last line of the file."





GetBraidRep::usage = "GetBraidRep[Pdata] calls an external program BraidFromSc2.exe. This returns a B-word of a braid representation for the given P-data. Untill braid representation for the given P-data is obtained, the P-data still in progress is reported. "	\





ShowBraid::usage ="ShowBraid[Bword,n:4,s:5] draw the braid obtained from B-word. B-word can be obtained by GetBraidRep,
		or you can specify by yourself. n and s are options; the larger parameters n and s are given, the smoother picture will be obtained." \






MutationOfTangle::usage="MutationOfTangle[P-data] calls an external program Mutatetangle.exe that operates mutate related operation on a new window. Tangle operation includes, flip, mutate, H-reverse, and V-reverse. After each operation, you can send the P-data to the Mathematica."





SkeinPolynomial::usage ="SkeinPolynomial[type, Pdata] gives 4 kinds of polynomials using an external program JonesPol.exe for the given P-data. Type 0, 1, -1, and -2 correspond to Jones,two variable Jones, Alexander by Conwayrelation, and Conway polynomial respectively."\

		

KauffmanPolynomial::usage="KauffmanPolynomial[Pdata] returns Kauffman polynomial for the given P-data using an external program KauffmanPol.exe"\

		

AlexanderPolynomialbyBurauRep::usage="AlexanderPolynomialbyBurauRep[Bword] returns the Alexander polynomial by Burau representation for the given B-word using an external program BurauAlexPol.exe. 
Notice; Maximum length of B-word is 100, and maximum number of strings is 12, therefore characters only A(a) to L(l) are available."\

		

ThreeParallelPolynomialInvariant::usage= "ThreeParallelPolynomialInvariant[Bword] returns one variable reduced invariant of the two variable Jones (or HOMFLY) polynomial of 3-parallel version for the given B-word using an external program ParallelLink.exe. This program needs to use a matrix file in the directory Braid_9, Braid_12, or Braid_15. Therefore be sure that these directory are placed in the directory K2K. 
Notice; This function needs memory so much. In case of lacking the memory, this returns nothing. Both maximum length of B-word and maximum number of strings depend on how much momory the machine, you're using, has."\

		

JonesPolynomialbyBraid::usage="JonesPolynomialbyBraid[Bword] returns the Jones polynomial by Hecke representation for the given B-word using an external program BraidRep.exe.
Notice; Maximum length of B-word is 100, and maximum number of strings is 12, therefore characters only A(a) to L(l) are available."





JonesPolynomialbyBraidFromFile::usage="JonesPolynomialbyBraid[BwordFileName] returns the Jones polynomials by Hecke representation for B-words in the B-word File. More than one B-word can be given through the file, and notice that EOF (or 555) needs to be in the last line of the file.
Notice; Maximum length of B-word is 100, and maximum number of strings is 12, therefore characters only A(a) to L(l) are available."





ShowKnotbyOpengl::usage="ShowKnotbyOpengl[Pdata] opens a new window to draw the knot (or link) diagram for the given P-data rendered by OpenGL. You can change outer domain by left-button click around the center of the face to be set outer domain. This function calls an external program KnotOgl.exe, and this program calls OpenGLKnot.exe which needs OpenGLDraw.dll. Be sure that both OpenGLKnot.exe and OpenGLDraw.dll are in the directory Knot2000."





KnotFromBraid::usage="KnotFromBraid[Bword] returns the P-data for the given B-word using an external program BwordToPword.exe."





ReductionKnotLink::usage = "ReductionKnotLink[Pdata] returns a P-data of the knot (or link) which was reduced the total number of crossings for the given knot (or link) diagram using an external program KnotLinkReduction.exe."





SkeinPolynomialFromFile::usage = "SkeinPolynomialFromFile[type,PdataFileName] prints the polynomials of the type specified by type parameter, for knots (or links) given by P-data (for file type) in the file. As for type value, see the usage of SkeinPolynomial. More than one P-data can be given through the file, and notice that EOF (or 555) needs to be in the last line of the file." \
 




GetMirrorImageKnot;(* exposing to the public context...*)

(* To keep mathlink programs working, 
  we need to expose the symbols they define in the KnotsByComputer` context. 
      Otherwise, 
  Install can't see the pre-existing symbols (in KnotsByComputer`Private`), 
  so it creates new ones in Global`. 
      Hopefully this is a complete list of the required symbols!
    
    Scott and Radmila, Feb 16 2006 *)

{Showwin,GetDrawData,ReductionKnotLink,BraidToPrd,ShowKnotOpengl,TangleWindow,\
knotlinkreduction,MirrorImageKnot,GetBraid,JonesTypePolynomial,\
KauffmanTypePolynomial,KnotByGauseanForm,kicktangleknot,MurakamiInv,\
SPolynomial,PolynomialKauffman,BurauAlexanderPol,ParallelRep,HeckeRep}

Begin["`Private`"]

$PolynomialNormal=False;

GetPdatabyTracking[]:= GetPdatabyTracking[""]
GetPdatabyTracking[str_String]:=
  	Module[
    		{m, link},
    link = Install["./MouseTracking", LinkMode->Launch]; 
    		m = Showwin[ToCharacterCode[str]];
    		Uninstall[link];
    		m
    		]				

ShowKnotfromPdata[pdata_List,s_:7, opts___]:=
	Block[
		{mm,aa, link},
    link = Install["./DrawKnot", LinkMode->Launch]; 
    		mm = GetDrawData[pdata[[2]],pdata[[1]]];
    		Uninstall[link];
    		aa=Table[ 
        ParametricPlot3D[framing[mm[[h]],i,t],{i,1,Length[mm[[h]]]},{t,0,1},
          PlotPoints -> {Length[mm[[h]]],s},DisplayFunction ->Identity],{h,1,
          Length[mm]}];
    		Show[aa,opts,DisplayFunction  -> $DisplayFunction, Ticks -> None,
      ViewPoint ->{0,0,4},Boxed ->False, Axes -> False];
    	]

framing[cord_List, i_,t_]:=
	Block[
		{v1,v2,v3,dis,eta,co,si,u,v,tt,k,r,p},
		eta =t 2 Pi;
		co = Cos[eta];
		si = Sin[eta];
		r = 0.3;
		v1 =  cord[[i]]; 
		If[i == Length[cord], v2 = cord[[2]],v2 = cord[[i+1]]];
		v3 ={v2[[1]] -v1[[1]],v2[[2]] -v1[[2]],v2[[3]] -v1[[3]]};
		u = {-v3[[2]],v3[[1]],0.0};
		dis = Sqrt[u[[1]]^2 + u[[2]]^2];
		tt = {r*u[[1]]/dis,r*u[[2]]/dis,r*u[[3]]/dis};
	   v = Cross[v3,tt]; 
		dis = Sqrt[v[[1]]^2 + v[[2]]^2 + v[[3]]^2];
		k = {r*v[[1]]/dis, r*v[[2]]/dis,r*v[[3]]/dis};
		p = {v2[[1]] + co*tt[[1]] + si*k[[1]],v2[[2]] + co*tt[[2]] + si*k[[2]],
        v2[[3]] + co*tt[[3]] + si*k[[3]]};
		{p[[1]],p[[2]],p[[3]]}
		]


WritheKnotFromPdata[pdata_]:=Apply[Plus,Map[(If[#<0,1,-1])&,pdata[[2]]]]

GetBraidRep[pdata_List]:=
	Block[
		{gb,pgb, link},
		pgb = pdata;
    link = Install["./BraidFromSc2", LinkMode->Launch];
    		gb = GetBraid[pdata[[2]],pdata[[1]]];
    		While[Length[gb] == 3,
      			pgb = {gb[[3]],gb[[2]]};
      			Print[pgb];
      			gb = GetBraid[gb[[2]],gb[[3]]];
      			];
    		Uninstall[link];
    		gb
    	]		




framing2[cord_List, i_,t_]:=
	Block[
		{v1,v2,v3,dis,u,v,tt,k,eta,ett,lcd,ss,co,si,r,p},
		eta =t 2 Pi;
		r = 0.1;
		co = Cos[eta];
		si = Sin[eta];
		If[i==0,v1=  cord[[i+1]],v1=cord[[i]]];
		lcd = Length[cord];
		If[lcd==2|| i==lcd||i==0,
			p = {v1[[1]], v1[[2]]+r*co,v1[[3]]+r*si},
			v2 = cord[[i+1]];
			v3 ={v2[[1]] -v1[[1]],v2[[2]] -v1[[2]],v2[[3]] -v1[[3]]};
			u = {-v3[[2]],v3[[1]],0.0};
			dis = Sqrt[u[[1]]^2 + u[[2]]^2];
			tt = {r*u[[1]]/dis,r*u[[2]]/dis,r*u[[3]]/dis};
			v = Cross[v3,tt]; 
			dis = Sqrt[v[[1]]^2 + v[[2]]^2 + v[[3]]^2];
			k = {r*v[[1]]/dis, r*v[[2]]/dis,r*v[[3]]/dis};
			p = {v2[[1]] + co*tt[[1]] + si*k[[1]],v2[[2]] + co*tt[[2]] + si*k[[2]],
          v2[[3]] + co*tt[[3]] + si*k[[3]]};
			];
		{p[[1]],p[[2]],p[[3]]}
	]



basicCord[pp_,up_,rd_]:=
	Block[{ppp,pp2,i,cod,eta},
		pp2 = 2*pp+1;
		cod = Table[0,{i,pp2}];
		ppp = Pi/(2*pp);
		For[i=1,i<=pp,i++,
			If[i ==1, j = 0.0,j=up*0.1*(i-2)];
			If[rd == 1, eta = Pi/2-ppp*(i-1),eta = -Pi/2+ppp*(i-1)];
			cod[[i]]={0.5*Cos[eta],0.5*Sin[eta], j};
			cod[[pp2+1-i]] = {1.0 -cod[[i,1]],0.0-cod[[i,2]],cod[[i,3]]};
			];
		cod[[pp+1]] = {0.5,0.0,cod[[pp,3]]};
		cod]



expandpower[bnum_]:=Block[{i,bnumx=bnum,fp,len,tlen,ch},tlen=Length[bnum];
    While[MemberQ[bnumx,32],
      bnumx=Delete[bnumx,First[First[Position[bnumx,32]]]];tlen--];
    While[MemberQ[bnumx,94],len=0;
      fp=First[First[Position[bnumx,94]]];
      bnumx=Delete[bnumx,fp];tlen--;
      While[
        fp\[LessEqual]tlen&&48\[LessEqual]bnumx[[fp]]&&
          bnumx[[fp]]\[LessEqual]57,len*=10;
        len+=bnumx[[fp]]-48;
        bnumx=Delete[bnumx,fp];tlen--];
      ch=bnumx[[fp-1]];
      For[i=1,i<len,i++,bnumx=Insert[bnumx,ch,fp];tlen++]];
    Return[bnumx]]





bwdtonumwd[bwd_]:=Block[{bnum,cds,len,i},bnum=ToCharacterCode[bwd];
    While[MemberQ[bnum,45],bnum=Delete[bnum,First[First[Position[bnum,45]]]];
      Print["The character - is illegal and so delete it"]];
    bnum=expandpower[bnum]; (*Modified by M.Ochiai*)len=Length[bnum];
    cds=Table[0,{i,len}];
    For[i=1,i\[LessEqual]len,i++,
      If[bnum[[i]]\[GreaterEqual]97,cds[[i]]=bnum[[i]]-96,
          cds[[i]]=64-bnum[[i]]];];
    cds]





ShowBraid[bwd_,n_:4,s_:5]:=
		Block[
		{bnum,c,i,j,h,bi,cds,cd,cc,cap1,cap2,low1,low2,cds2,cyl,st},
		bnum = bwdtonumwd[bwd];
		c = Length[bnum];	
    	     st=Abs[bnum[[1]]];
    		For[i=2,i<=c,i++,
      			If[Abs[bnum[[i]]]>=st, st=Abs[bnum[[i]]]]];
    							
    		cap1 =framed[basicCord[n,-1,1],s];
    		cap2 =framed[basicCord[n,1,-1],s];
    		low1 =framed[basicCord[n,1,1],s];
    		low2 =framed[basicCord[n,-1,-1],s];
    		cyl = framed[{{0.0,0.5,0.0},{1.0,0.5,0.0}},s];
    		cyl ={cyl[[2]],cyl[[3]]};
    		
    		cds = Table[0,{i,c},{j,st+1}];
    		cd = Table[0,{j,s}];
    		cd1 = Table[0,{i,s}];
    		cd2 = Table[0,{i,s}];
    		cds2 = Table[0,{i,n*2+1}];
    		
    		For[i=1,i<=c,i++,
      			bi=bnum[[i]];
      			If[bi < 0, sg = 1;bi=-bi,sg =-1];
      			For[j=1,j<=st+1,j++,
        				If[j<bi || bi+1<j,
          					For[h = 1, h<=s,h++,
            						cd1[[h]]={i-1,1.5-j+cyl[[1,h,2]],cyl[[1,h,3]]};
            						cd2[[h]] ={i,1.5-j+cyl[[2,h,2]],cyl[[2,h,3]]};];
          						cds[[i,j]]={cd1,cd2},
          							
          					For[h =1,h<=n*2+1,h++,
            						If[j == bi,
                							If[sg ==1,
                  								For[k =1,k<=s,k++,
                    									
                    cd[[k]]={i-1+cap1[[h,k,1]],1.5-j+cap1[[h,k,2]],
                        cap1[[h,k,3]]}];
                  								cds2[[h]] =cd,
                  								For[k =1,k<=s,k++,
                    									
                    cd[[k]]={i-1+low1[[h,k,1]],1.5-j+low1[[h,k,2]],
                        low1[[h,k,3]]}];
                  								cds2[[h]] = cd],
                							If[sg ==1,
                    								For[k =1,k<=s,k++,
                      									
                      cd[[k]]={i-1+cap2[[h,k,1]],1.5-j+1+cap2[[h,k,2]],
                          cap2[[h,k,3]]}];
                    								cds2[[h]] = cd,
                    								For[k =1,k<=s,k++,
                      									
                      cd[[k]]={i-1+low2[[h,k,1]],1.5-j+1+low2[[h,k,2]],
                          low2[[h,k,3]]}];
                    								cds2[[h]] = cd
                    								];
                							];
            						];
          					cds[[i,j]]=cds2
          					]
        			]
      		];
    		
    		cc=Table[ 
        ParametricPlot3D[cds[[i,j,h,t]],{h,1,Length[cds[[i,j]]]},{t,1,s},
          PlotPoints -> {Length[cds[[i,j]]],s},DisplayFunction ->Identity],
        					{i,1,c},{j,1,st+1}];
    		Show[cc,DisplayFunction  -> $DisplayFunction, Ticks -> None,
      ViewPoint ->{0,0,4}];
    	]




framed[cord_List,n_]:=Block[{i,h,m,mm,pp},
		pp = Table[0,{i,Length[cord]+1},{h,n}];
		m= 0.0; mm=1.0/n;
		For[i=1,i<=Length[cord]+1,i++,
			For[h=1,h<=n,h++,
				pp[[i,h]]=Chop[framing2[cord,i-1,m]];
				m = m+mm;
				];
			];
		pp]




SkeinPolynomial[type_Integer, pdat_List]:=
	Block[{jonespol,pdata,nump,x,y,t,m, retcode, link},
    link = Install["./JonesPol", LinkMode->Launch];
    		pdata = pdat[[2]]; nump = pdat[[1]];
    	retcode=JonesTypePolynomial[type,pdata,nump];
    	If[First[retcode]\[Equal]0,Return[Last[retcode]]];
    		jonespol =ToExpression[Last[retcode]];
    If[$PolynomialNormal\[Equal]True,
        jonespol=Numerator[Together[jonespol]]];
    	If[type==0,
      	jonespol=jonespol  /. {x\[Rule]Sqrt[t]};
      		Print["Jones Polynomial for ", "[",pdat , "]"]];
    	If[type==-1,
      	jonespol=jonespol  /. {x\[Rule]Sqrt[t]};
      		Print["Alexander Polynomial for ", "[", pdat, "]"]];
    	If[type==-2,
      	jonespol=jonespol  /. {x\[Rule]Sqrt[t]};
      		Print["Conway Polynomial for ", "[",pdat, "]"]];
         If[type==1,
      	      Print["Two variable Jones Polynomial for ", "[",pdat, "]"]];
    	Uninstall[link];
    	Return[jonespol]
    	]

SPolynomial[type_Integer, pdat_List]:=
	Block[{jonespol,pdata,nump,x,y,t,m,retcode},
		pdata = pdat[[2]]; nump = pdat[[1]];
    retcode=JonesTypePolynomial[type,pdata,nump];
    	If[First[retcode]\[Equal]0,Return[Last[retcode]]];
    		jonespol =ToExpression[Last[retcode]];
    If[$PolynomialNormal\[Equal]True,
        jonespol=Numerator[Together[jonespol]]];
    	If[type==0,
      	jonespol=jonespol  /. {x\[Rule]Sqrt[t]};
      		Print["Jones Polynomial for ", "[",pdat , "]"]];
    	If[type==-1,
      	jonespol=jonespol  /. {x\[Rule]Sqrt[t]};
      		Print["Alexander Polynomial for ", "[", pdat, "]"]];
    	If[type==-2,
      	jonespol=jonespol  /. {x\[Rule]Sqrt[t]};
      		Print["Conway Polynomial for ", "[",pdat, "]"]];
         If[type==1,
      	      Print["Two variable Jones Polynomial for ", "[",pdat, "]"]];
    	Return[jonespol]
    	]




SkeinPolynomialFromFile[type_,str_String]:=
  Block[{snum,n,n2,com,nump,prd,pol, link},
    snum=OpenRead[str];
    If[snum==$Failed,Print["Cannot open ",str,"."];Return[]];
    link = Install["./JonesPol", LinkMode->Launch];
    While[True,
      n2=ReadNum[snum];n=n2/2;
      prd=Table[0,{i,n}];
      If[n2\[Equal]555 || n2\[Equal]5555,Break[]];
      com=ReadNum[snum];
      nump=Table[0,{i,com}];
      For[i=1, i\[LessEqual]com,i++,
        nump[[i]]=ReadNum[snum]/2];
      For[i=1, i\[LessEqual]n,i++,
        prd[[i]]=ReadNum[snum]];
      pol=SPolynomial[type,{nump,prd}];
      Print[pol]];
    Uninstall[link];
    Close[snum]
    ]






KauffmanPolynomial[pdat_]:=
	Block[{polstr,kauffmanpol,pdata,nump,type, link},
		type = 0;
		pdata = pdat[[2]]; 
    	     nump = pdat[[1]];
    link = Install["./KauffmanPol", LinkMode->Launch];
    		polstr =KauffmanTypePolynomial[type,pdata,nump];
    	If[$PolynomialNormal\[Equal]True,
      		kauffmanpol =Numerator[Together[ToExpression[Last[polstr]]]],
      kauffmanpol=ToExpression[Last[polstr]]] ;
    		Print["Kauffman Polynomial for ", "[",pdat, "]"];
    		Uninstall[link];
    		Return[kauffmanpol]
    	]

KauffmanPolynomial[type_Integer, pdat_List]:=
	Block[{polstr,pdata,nump,kauffmanpol, link},
    	pdata = pdat[[2]]; 
    	nump = pdat[[1]];
    link = Install["./KauffmanPol", LinkMode->Launch];
    	    polstr =KauffmanTypePolynomial[type,pdata,nump];
    If[$PolynomialNormal\[Equal]True,
      	    kauffmanpol =Numerator[Together[ToExpression[Last[polstr]]]],
      kauffmanpol=ToExpression[Last[polstr]]] ;
             If[type\[Equal]0,
      		Print["Kauffman Polynomial of ",pdat],
      	   Print["Q-Polynomial of ", pdat]];
    		Uninstall[link];
    		Return[kauffmanpol]
    	]


PolynomialKauffman[type_Integer, pdat_List]:=
	Block[{polstr,pdata,nump,pol},
    	pdata = pdat[[2]]; 
    	nump = pdat[[1]];
    	polstr =KauffmanTypePolynomial[type,pdata,nump];
    If[$PolynomialNormal\[Equal]True,
      pol =Numerator[Together[ToExpression[Last[polstr]]]],
      pol=ToExpression[Last[polstr]]] ;
    If[type\[Equal]0,
      		Print["Kauffman Polynomial of ", pdat],
      Print["Q-Polynomial of ",pdat]];
    		Return[pol]
    	]

KauffmanPolynomialFromFile[type_Integer,str_String]:=
  Block[{snum,n,n2,com,nump,prd,pol, link},
    snum=OpenRead[str];
    If[snum==$Failed,Print["Cannot open ",str,"."];Return[]];
    link = Install["./KauffmanPol", LinkMode->Launch];
    While[True,
      n2=ReadNum[snum];n=n2/2;
      prd=Table[0,{i,n}];
      If[n2\[Equal]555 || n2\[Equal]5555,Break[]];
      com=ReadNum[snum];
      nump=Table[0,{i,com}];
      For[i=1, i\[LessEqual]com,i++,
        nump[[i]]=ReadNum[snum]/2];
      For[i=1, i\[LessEqual]n,i++,
        prd[[i]]=ReadNum[snum]];
      pol=PolynomialKauffman[type,{nump,prd}];
      Print[pol]];
    Uninstall[link];
    Close[snum]
    ]

AlexanderPolynomialbyBurauRep[bword_]:=
  Block[{i,c,st,bbwd,polstr,alexpol, link},
    bbwd = bwdtonumwd[bword];
    c = Length[bbwd];
    If[c>100,Print["B-word is too long."];Break[]];
    st=Abs[bbwd[[1]]];
    For[i=2,i<=c,i++,
      If[Abs[bbwd[[i]]]>=st, st=Abs[bbwd[[i]]]]];
    bbwd=Prepend[bbwd,st+1];
    link = Install["./buraualexpol", LinkMode->Launch];
    polstr =BurauAlexanderPol[First[bbwd],bbwd];
    If[$PolynomialNormal\[Equal]True,
      alexpol=Numerator[Together[ToExpression[polstr]]] ,
      alexpol=ToExpression[polstr]];
    alexpol=alexpol /. {x\[Rule]t};
    Print["Alexander Polynomial by Burau representation for", "[", bword, 
      "]"];
    Uninstall[link];
    Return[alexpol];
    ]



AlexanderPolynomialbyBurauRepFromFile[str_]:=
  Block[{c,bbwd,st,pol,polex,snum,bword,x,t, link},
    snum=OpenRead[str];
    If[snum==$Failed,Print["Cannot open ",str,"."];Return[]];
    link = Install["./buraualexpol", LinkMode->Launch];
    While[True,
      bword=Read[snum,String];
      If[bword\[Equal]"555" || bword\[Equal]"5555",
        Break[]];
      bbwd=bwdtonumwd[bword];
      c = Length[bbwd];
      If[c>100,Print["B-word is too long."];Break[]];
      st=Abs[bbwd[[1]]];
      For[i=2,i<=c,i++,
        		If[Abs[bbwd[[i]]]>=st, st=Abs[bbwd[[i]]]]];
      bbwd=Prepend[bbwd,st+1];
      pol=BurauAlexanderPol[First[bbwd],bbwd];
      If[$PolynomialNormal\[Equal]True,
        polex=Numerator[Together[ToExpression[pol]]],
        polex=ToExpression[pol]];
      polex=polex /. {x\[Rule]t};
      Print["Alexander Polynomial by Burau representation for", "[", bword, 
        "]"];
      Print[polex]];
    Uninstall[link];
    Close[snum]
    ]




\!\(ThreeParallelPolynomialInvariant[bword_] := \[IndentingNewLine]Block[{i, x, \ q, \ bbwd, polstr, jonespol, c, st, wythe, \ ex, link}, \[IndentingNewLine]bbwd\  = \ bwdtonumwd[bword]; \[IndentingNewLine]c\  = \ Length[bbwd]; \[IndentingNewLine]If[c > 100, Print["\<B-word is too long.\>"]; Break[]]; \[IndentingNewLine]st = Abs[bbwd[\([1]\)]]; \[IndentingNewLine]wythe = 0; \[IndentingNewLine]If[bbwd[\([1]\)] > 0, \(wythe++\), \(wythe--\)]; \[IndentingNewLine]For[i = 2, i <= c, \(i++\), \[IndentingNewLine]If[bbwd[\([i]\)] > 0, \(wythe++\), \(wythe--\)]; \[IndentingNewLine]If[Abs[bbwd[\([i]\)]] >= st, \ st = Abs[bbwd[\([i]\)]]]]; \[IndentingNewLine]bbwd = Prepend[bbwd, st + 1]; \[IndentingNewLine]link\  = \ Install["\<./ParallelLink\>", \ LinkMode -> Launch]; \[IndentingNewLine]polstr\  = ParallelRep[First[bbwd], bbwd]; \[IndentingNewLine]wythe = 3*wythe; \[IndentingNewLine]jonespol\  = ToExpression[polstr]; \[IndentingNewLine]jonespol = \ jonespol\  /. \ {x -> Sqrt[q]}; \[IndentingNewLine]ex = \((q^\((3/2)\))\)^wythe; \[IndentingNewLine]jonespol = ex*jonespol; \[IndentingNewLine]ex = \((1 - q^4)\)/\((q^\((3/2)\) \((1 - q)\))\); \[IndentingNewLine]jonespol = jonespol*ex^\((3*\((st + 1)\) - 1)\); \[IndentingNewLine]ex = q^2*\((1 + q + q\^2 + q\^3)\)^\((\(-3\) \((st + 1)\))\)/\((1 + q + q\^2 + q\^3 + q\^4)\); \[IndentingNewLine]jonespol = jonespol\ *ex; \[IndentingNewLine]Print["\<3-parallel one variable invariant for \>", \ "\<[\>", \ bword, \ "\<]\>"]; \[IndentingNewLine]Uninstall[link]; \[IndentingNewLine]jonespol = Simplify[Expand[jonespol]]; \[IndentingNewLine]If[jonespol \[Equal] \(-1\), jonespol = 1]; \[IndentingNewLine]If[jonespol != 1, jonespol = Simplify[jonespol/ex]]; \[IndentingNewLine]Return[jonespol]\[IndentingNewLine]]\)




JonesPolynomialbyBraid[bword_]:=
  Block[{bbwd,pol,polex,x,t,c,st, link},
    bbwd=bwdtonumwd[bword];
    c = Length[bbwd];
    If[c>100,Print["B-word is too long."];Break[]];
    st=Abs[bbwd[[1]]];
    For[i=2,i<=c,i++,
      		If[Abs[bbwd[[i]]]>=st, st=Abs[bbwd[[i]]]]];
    bbwd=Prepend[bbwd,st+1];
    link = Install["./braidrep", LinkMode->Launch];
    pol=HeckeRep[First[bbwd],bbwd];
    If[$PolynomialNormal\[Equal]True,
      polex=Numerator[Together[ToExpression[pol]]],polex=ToExpression[pol]];
    polex=polex /. {x\[Rule]Sqrt[t]};
    Print["Jones Polynomial by Hecke representation for [",bword, "]"];
    Uninstall[link];
    Return[polex];
    ]




JonesPolynomialbyBraidFromFile[str_]:=
  Block[{c,bbwd,st,pol,polex,snum,bword,x,t, link},
    snum=OpenRead[str];
    If[snum==$Failed,Print["Cannot open ",str,"."];Return[]];
    link=Install["./braidrep", LinkMode->Launch];
    While[True,
      bword=Read[snum,String];
      If[bword\[Equal]"555" || bword\[Equal]"5555",
        Break[]];
      bbwd=bwdtonumwd[bword];
      c = Length[bbwd];
      If[c>100,Print["B-word is too long."];Break[]];
      st=Abs[bbwd[[1]]];
      For[i=2,i<=c,i++,
        		If[Abs[bbwd[[i]]]>=st, st=Abs[bbwd[[i]]]]];
      bbwd=Prepend[bbwd,st+1];
      pol=HeckeRep[First[bbwd],bbwd];
      If[$PolynomialNormal\[Equal]True,
        polex=Numerator[Together[ToExpression[pol]]],
        polex=ToExpression[pol]];
      polex=polex /. {x\[Rule]Sqrt[t]};
      Print["Jones Polynomial by Hecke representation for [",bword,"]"];
      Print[polex]];
    Uninstall[link];
    Close[snum]
    ]




ReductionKnotLink[pdata_List]:=Block[{prd, link},
    link=Install["./KnotLinkReduction", LinkMode->Launch];
    	prd = knotlinkreduction[pdata[[2]],pdata[[1]]];
    	Uninstall[link];
    	Return[prd]
    ]




GetMirrorImageKnot[pdata_List]:=Block[{prd, link},
    link=Install["./MirrorImage", LinkMode->Launch];
    prd=MirrorImageKnot[pdata[[2]],pdata[[1]]];
    Uninstall[link];
    Return[prd]
    ]

MutationOfTangle[pdata_List]:=Block[{prd, link},
    link=Install["./MutateTangle", LinkMode->Launch];
       prd=TangleWindow[pdata[[2]],pdata[[1]]];
    Uninstall[link];
    Return[prd]]





ShowKnotbyOpengl[pdata_List]:=Block[{link},
    link=Install["./KnotOgl", LinkMode->Launch];
    ShowKnotOpengl[pdata[[2]],pdata[[1]]];
    Uninstall[link]
    ]




KnotFromBraid[braid_String]:=Block[{bnum,size,prd, link},
    bnum=bwdtonumwd[braid];
    size=Max[Map[(Abs[#])&,bnum]]+1;
    link=Install["./BwordToPword", LinkMode->Launch];
    prd=BraidToPrd[bnum,size];
    Uninstall[link];
    prd
    ]




ReadNum[snum_]:=Module[{num},
    num=Read[snum,Number];
    While[!NumberQ[num],num=Read[snum,Number]];
    num
    ]
TransformPrdOfFile[str_String]:=Block[{snum,n,n2,com,nump,prd},
    snum=OpenRead[str];
    While[True,
      n2=ReadNum[snum];n=n2/2;
      prd=Table[0,{i,n}];
      If[n2\[Equal]555,Break[]];
      com=ReadNum[snum];
      nump=Table[0,{i,com}];
      For[i=1, i\[LessEqual]com,i++,
        nump[[i]]=ReadNum[snum]/2];
      For[i=1, i\[LessEqual]n,i++,
        prd[[i]]=ReadNum[snum]];
      Print[{nump,prd}]];
    Close[snum]
    ]




ShowKnotFronFile[str_String]:=Block[{snum,n,n2,com,nump,prd},
    snum=OpenRead[str];
    If[snum==$Failed,Print["Cannot open ",str,"."];Return[]];While[True,
      n2=ReadNum[snum];n=n2/2;
      prd=Table[0,{i,n}];
      If[n2\[Equal]555 || n2\[Equal]5555,Break[]];
      com=ReadNum[snum];
      nump=Table[0,{i,com}];
      For[i=1, i\[LessEqual]com,i++,
        nump[[i]]=ReadNum[snum]/2];
      For[i=1, i\[LessEqual]n,i++,
        prd[[i]]=ReadNum[snum]];
      ShowKnotfromPdata[{nump,prd}]];
    Close[snum]
    ]






GetBraidRepFromFile[str_String,otype_Integer:0]:=
	Block[
		{gb,pgb,snum,n,n2,com,n0=0,com0=0,nump,prd,pdata,rep,ofile,totalcount,
      link},
    snum=OpenRead[str];
    If[snum==$Failed,Print["Cannot open ",str,"."];Return[]];
    link=Install["./BraidFromSc2", LinkMode->Launch];
    If[otype\[NotEqual]0,ofile=OpenWrite["BraidForm.brd"]];
    totalcount=0;
    While[True,
      n2=ReadNum[snum];n=n2/2;
      If[n\[NotEqual]n0,n0=n;prd=Table[0,{i,n}]];
      If[n2\[Equal]555 || n2\[Equal]5555,Break[]];
      totalcount++;
      com=ReadNum[snum];
      If[com\[NotEqual]com0,com0=com;nump=Table[0,{i,com}]];
      For[i=1, i\[LessEqual]com,i++,
        nump[[i]]=ReadNum[snum]/2];
      For[i=1, i\[LessEqual]n,i++,
        prd[[i]]=ReadNum[snum]];
      pdata={nump,prd};
      rep=1;
      If[otype \[NotEqual]2,Print[pdata],
        If[Mod[totalcount,100]\[Equal]0,Print[totalcount]]];
             Label[back];
      pgb = pdata;
      gb = GetBraid[pdata[[2]],pdata[[1]]];
             While[Length[gb] == 3,
        		pgb = {gb[[3]],gb[[2]]};
        		gb = GetBraid[gb[[2]],gb[[3]]];
               ];
      If[rep<n && MemberQ[ToCharacterCode[gb],64],
        pdata=ReductionKnotLink[pdata];Print[totalcount,":Retry-> ",rep];rep++;
        Goto[back]];
      If[otype\[Equal]0,
        	Print[gb],
        WriteString[ofile,StringInsert[gb,"\n",-1]]];
      ];
    Close[snum];
    Uninstall[link];
    If[otype\[NotEqual]0,WriteString[ofile,"555\n"];Close[ofile];
      Print["The output data was stored in BraidForm.brd"];
      Print[
        "If you would want to see the result, please keyin !!BraidForm.brd"];
      ]
    ]


SQTable={
      {1-\[Lambda] q,q-\[Lambda] q,q^2-\[Lambda] q,q^3-\[Lambda] q,
        q^4-\[Lambda] q,q^5-\[Lambda] q,q^6-\[Lambda] q,q^7-\[Lambda] q,
        q^8-\[Lambda] q,
        q^9-\[Lambda] q,q^10-\[Lambda] q,q^11-\[Lambda] q,q^12-\[Lambda] q,
        q^13-\[Lambda] q,q^14-\[Lambda] q},
      {1-\[Lambda] q^2,q-\[Lambda] q^2,q^2-\[Lambda] q^2,q^3-\[Lambda] q^2,
        q^4-\[Lambda] q^2,q^5-\[Lambda] q^2,q^6-\[Lambda] q^2,
        q^7-\[Lambda] q^2,q^8-\[Lambda] q^2,q^9-\[Lambda] q^2,
        q^10-\[Lambda] q^2,q^11-\[Lambda] q^2,q^12-\[Lambda] q^2,
        q^13-\[Lambda] q^2,q^14-\[Lambda] q^2},
      {1-\[Lambda] q^3,q-\[Lambda] q^3,q^2-\[Lambda] q^3,q^3-\[Lambda] q^3,
        q^4-\[Lambda] q^3,q^5-\[Lambda] q^3,q^6-\[Lambda] q^3,
        q^7-\[Lambda] q^3,q^8-\[Lambda] q^3,q^9-\[Lambda] q^3,
        q^10-\[Lambda] q^3,q^11-\[Lambda] q^3,q^12-\[Lambda] q^3,
        q^13-\[Lambda] q^3,q^14-\[Lambda] q^3},
      {1-\[Lambda] q^4,q-\[Lambda] q^4,q^2-\[Lambda] q^4,q^3-\[Lambda] q^4,
        q^4-\[Lambda] q^4,q^5-\[Lambda] q^4,q^6-\[Lambda] q^4,
        q^7-\[Lambda] q^4,q^8-\[Lambda] q^4,q^9-\[Lambda] q^4,
        q^10-\[Lambda] q^4,q^11-\[Lambda] q^4,q^12-\[Lambda] q^4,
        q^13-\[Lambda] q^4,q^14-\[Lambda] q^4},
      {1-\[Lambda] q^5,q-\[Lambda] q^5,q^2-\[Lambda] q^5,q^3-\[Lambda] q^5,
        q^4-\[Lambda] q^5,q^5-\[Lambda] q^5,q^6-\[Lambda] q^5,
        q^7-\[Lambda] q^5,q^8-\[Lambda] q^5,q^9-\[Lambda] q^5,
        q^10-\[Lambda] q^5,q^11-\[Lambda] q^5,q^12-\[Lambda] q^5,
        q^13-\[Lambda] q^5,q^14-\[Lambda] q^5},
      {1-\[Lambda] q^6,q-\[Lambda] q^6,q^2-\[Lambda] q^6,q^3-\[Lambda] q^6,
        q^4-\[Lambda] q^6,q^5-\[Lambda] q^6,q^6-\[Lambda] q^6,
        q^7-\[Lambda] q^6,q^8-\[Lambda] q^6,q^9-\[Lambda] q^6,
        q^10-\[Lambda] q^6,q^11-\[Lambda] q^6,q^12-\[Lambda] q^6,
        q^13-\[Lambda] q^6,q^14-\[Lambda] q^6},
      {1-\[Lambda] q^7,q-\[Lambda] q^7,q^2-\[Lambda] q^7,q^3-\[Lambda] q^7,
        q^4-\[Lambda] q^7,q^5-\[Lambda] q^7,q^6-\[Lambda] q^7,
        q^7-\[Lambda] q^7,q^8-\[Lambda] q^7,q^9-\[Lambda] q^7,
        q^10-\[Lambda] q^7,q^11-\[Lambda] q^7,q^12-\[Lambda] q^7,
        q^13-\[Lambda] q^7,q^14-\[Lambda] q^7},
      {1-\[Lambda] q^8,q-\[Lambda] q^8,q^2-\[Lambda] q^8,q^3-\[Lambda] q^8,
        q^4-\[Lambda] q^8,q^5-\[Lambda] q^8,q^6-\[Lambda] q^8,
        q^7-\[Lambda] q^8,q^8-\[Lambda] q^8,q^9-\[Lambda] q^8,
        q^10-\[Lambda] q^8,q^11-\[Lambda] q^8,q^12-\[Lambda] q^8,
        q^13-\[Lambda] q^8,q^14-\[Lambda] q^8},
      {1-\[Lambda] q^9,q-\[Lambda] q^9,q^2-\[Lambda] q^9,q^3-\[Lambda] q^9,
        q^4-\[Lambda] q^9,q^5-\[Lambda] q^9,q^6-\[Lambda] q^9,
        q^7-\[Lambda] q^9,q^8-\[Lambda] q^9,q^9-\[Lambda] q^9,
        q^10-\[Lambda] q^9,q^11-\[Lambda] q^9,q^12-\[Lambda] q^9,
        q^13-\[Lambda] q^9,q^14-\[Lambda] q^9},
      {1-\[Lambda] q^10,q-\[Lambda] q^10,q^2-\[Lambda] q^10,
        q^3-\[Lambda] q^10,q^4-\[Lambda] q^10,q^5-\[Lambda] q^10,
        q^6-\[Lambda] q^10,q^7-\[Lambda] q^10,q^8-\[Lambda] q^10,
        q^9-\[Lambda] q^10,q^10-\[Lambda] q^10,q^11-\[Lambda] q^10,
        q^12-\[Lambda] q^10,q^13-\[Lambda] q^10,q^14-\[Lambda] q^10},
      {1-\[Lambda] q^11,q-\[Lambda] q^11,q^2-\[Lambda] q^11,
        q^3-\[Lambda] q^11,q^4-\[Lambda] q^11,q^5-\[Lambda] q^11,
        q^6-\[Lambda] q^11,q^7-\[Lambda] q^11,q^8-\[Lambda] q^11,
        q^9-\[Lambda] q^11,q^10-\[Lambda] q^11,q^11-\[Lambda] q^11,
        q^12-\[Lambda] q^11,q^13-\[Lambda] q^11,q^14-\[Lambda] q^11},
      {1-\[Lambda] q^12,q-\[Lambda] q^12,q^2-\[Lambda] q^12,
        q^3-\[Lambda] q^12,q^4-\[Lambda] q^12,q^5-\[Lambda] q^12,
        q^6-\[Lambda] q^12,q^7-\[Lambda] q^12,q^8-\[Lambda] q^12,
        q^9-\[Lambda] q^12,q^10-\[Lambda] q^12,q^11-\[Lambda] q^12,
        q^12-\[Lambda] q^12,q^13-\[Lambda] q^12,q^14-\[Lambda] q^12},
      {1-\[Lambda] q^13,q-\[Lambda] q^13,q^2-\[Lambda] q^13,
        q^3-\[Lambda] q^13,q^4-\[Lambda] q^13,q^5-\[Lambda] q^13,
        q^6-\[Lambda] q^13,q^7-\[Lambda] q^13,q^8-\[Lambda] q^13,
        q^9-\[Lambda] q^13,q^10-\[Lambda] q^13,q^11-\[Lambda] q^13,
        q^12-\[Lambda] q^13,q^13-\[Lambda] q^13,q^14-\[Lambda] q^13},
      {1-\[Lambda] q^14,q-\[Lambda] q^14,q^2-\[Lambda] q^14,
        q^3-\[Lambda] q^14,q^4-\[Lambda] q^14,q^5-\[Lambda] q^14,
        q^6-\[Lambda] q^14,q^7-\[Lambda] q^14,q^8-\[Lambda] q^14,
        q^9-\[Lambda] q^14,q^10-\[Lambda] q^14,q^11-\[Lambda] q^14,
        q^12-\[Lambda] q^14,q^13-\[Lambda] q^14,q^14-\[Lambda] q^14},
      {1-\[Lambda] q^15,q-\[Lambda] q^15,q^2-\[Lambda] q^15,
        q^3-\[Lambda] q^15,q^4-\[Lambda] q^15,q^5-\[Lambda] q^15,
        q^6-\[Lambda] q^15,q^7-\[Lambda] q^15,q^8-\[Lambda] q^15,
        q^9-\[Lambda] q^15,q^10-\[Lambda] q^15,q^11-\[Lambda] q^15,
        q^12-\[Lambda] q^15,q^13-\[Lambda] q^15,q^14-\[Lambda] q^15}};
        

ComputeWeight[yg_,dpt_]:=Block[{i,j,k,t,q,len,polnum,polden,hook,hooktable},
    hooktable=Table[0,{i,16},{j,16}];
    len=Length[yg];
    For [i=1,i<=dpt, i++,
      For [j=1, i\[LessEqual]len && j\[LessEqual]yg[[i]], j++,
        hooktable[[j,i]]=1]];
    polnum=1;polden=1;
    For [i=1,i<=dpt, i++, 
      For[j=1,i\[LessEqual]len && j\[LessEqual]yg[[i]],j++, 
        polnum *= SQTable[[j,i]];
        hook=0;
        For[k=j,
          i\[LessEqual]len && k\[LessEqual]yg[[i]] && 
            hooktable[[k,i]]\[NotEqual] 0,k++,
           hook++];
        For[k=i+1,k\[LessEqual]dpt && hooktable[[j,k]]\[NotEqual] 0,k++,
           hook++];
        polden *= (1-q^hook)]];
    Return[{polnum,polden}]
    ]
SLInvarint[bword_]:=
  Block[{i,bbwd,c,st,wythe,ex,t,q,yg,sln,weight,tr,index, link},
    bbwd = bwdtonumwd[bword];
    c = Length[bbwd];
    If[c>100,Print["B-word is too long."];Break[]];
    st=Abs[bbwd[[1]]];
    For[i=2,i<=c,i++,
      If[Abs[bbwd[[i]]]>=st, st=Abs[bbwd[[i]]]]];
    bbwd=Prepend[bbwd,st+1];
    link=Install["./ParallelLink2", LinkMode->Launch];
    ex =MurakamiInv[First[bbwd],bbwd];
    ex = ToExpression[ex];
    Uninstall[link];
    If[ex\[Equal]{},Return["Fail to compute."]];
    index=3*First[bbwd];
    sln = 0;
    wythe=First[ex];
    ex=Rest[ex];
    While[True,
      If[ex\[Equal]{},Break[]];
      yg=First[ex];
      ex=Rest[ex];
      tr=(First[ex] /. x\[Rule]Sqrt[q]);
      
      weight=ComputeWeight[yg,index];
      tr=Factor[tr];
      sln +=
        Factor[ weight[[1]] * Numerator[tr]/(Denominator[tr]*weight[[2]])];
      
      ex=Rest[ex];
      ];
    Print["3-parallel sl_n invariant for ", "[", bword, "]"];
    ex=Sqrt[\[Lambda]]^wythe;
    ex *= ((1-\[Lambda] q)/(Sqrt[\[Lambda]](q-1)))^(First[bbwd]-1);
    Return[Factor[ex*sln]];
    ]

TotalDataListFromDataFile[fname_]:=Block[{sn,ex,str,totaldata={}},
    sn=OpenRead[fname];
    If[sn==$Failed,Print["Can't open ",fname,"."];Return[]];
    While[True,
      ex=Read[sn,String];
      If[ex\[Equal]EndOfFile,Break[]];
      If[StringLength[ex]\[NotEqual]0 && StringLength[ex]<10,
        str=StringToStream[ex];
        ex=ReadList[str,Number];
        totaldata=Append[totaldata,ex];
        Close[str];
        ];
      ];
    Close[sn];
    Return[Flatten[totaldata]]
    ]

NextPt[n_,com_,comppos_]:=Block[{i},
    For[i=2,i<=com,i++,
      If[n<comppos[[i,1]]-1,Return[n+1]];
      If[n\[Equal]comppos[[i,1]]-1,Return[comppos[[i-1,1]]]];
      ]
    ]

CrossingPoint[p1_,p2_,p3_,p4_]:=Block[{mm,v},
        mm={{p2[[2]]-p1[[2]],p1[[1]]-p2[[1]]},{
                    p4[[2]]-p3[[2]],p3[[1]]-p4[[1]]}};
        v={p1[[1]]*p2[[2]]-p2[[1]]*p1[[2]],p3[[1]]*p4[[2]]-p4[[1]]*p3[[2]]};
        Return[Round[N[LinearSolve[mm,v],20]]]
        ]

Distance[p1_,p2_]:=Round[N[Sqrt[(p1[[1]]-p2[[1]])^2+(p1[[2]]-p2[[2]])^2]]];

FindDistance[xy_,cplist_,cpinfo_]:=Block[{i,j,d,len,cp,cp1,dl={},tmp,mind},
        cp=cplist;cp1=cpinfo;
        len=Length[cp];
        For[i=1,i\[LessEqual]len,i++,
            d=Distance[xy[[Abs[cp[[i,1]]]]],cp[[i,2]]];
            dl=Append[dl,{Abs[cp[[i,1]]],d}]
            ];
        For[i=1,i<len,i++,
            mind=dl[[i,2]];
            For[j=i+1,j\[LessEqual]len,j++,
                If[dl[[i,1]]\[Equal]dl[[j,1]] &&  dl[[j,2]]<mind ,
                    tmp=cp[[j]]; cp[[j]]=cp[[i]];
                    cp[[i]]=tmp; mind=dl[[j,2]];tmp=dl[[j,2]];
          dl[[j,2]]=dl[[i,2]];dl[[i,2]]=tmp;
          tmp=cp1[[j]];cp1[[j]]=cp1[[i]];cp1[[i]]=tmp
                    ];
                If[dl[[i,1]]!=dl[[j,1]],Break[]]
                ]
            ];
          Return[{cp,cp1}]
        ]

CrossSign[p1_,p2_,p4_]:=Block[{s},
    s=p1[[1]]*(p4[[2]]-p2[[2]])+p4[[1]]*(p2[[2]]-p1[[2]])+
        p2[[1]]*(p1[[2]]-p4[[2]]);
    If[s>0, Return[True],Return[False]]
    ]

PLDataFromSnapPeaData[fname_]:=
  Block[{i,j,k,k0,m,n,len,ex,ex1,tmp,spd={},com,comppos,xy,edge,crossing,
      under,overcr,toppt,tail,p1,p2,p3,p4,cp,cplist={},cpsign={},cpinfo={},
      nump={},pdata={},pdataa={},pdatab={},fileid},
        ex=TotalDataListFromDataFile[fname];
        For[j=1,j\[LessEqual]4,j++,
            tmp={};
              n=First[ex]; ex=Delete[ex,1];
              For[i=1,i\[LessEqual]n,i++,
                  tmp=Append[tmp,Take[ex,{1,2}]];
                  ex=Drop[ex,2]
                  ];
            spd=Append[spd,tmp];
            ];
        n=First[ex]; ex=Delete[ex,1];
        If[n!=-1,
      Print["Can't find the separator (-1) of SnapPea. Please change ",n,
        " to -1 and retry."];Close[fileid];Return[False]];
        fileid=OpenWrite["PLFromSnappea.sp",FormatType\[Rule]OutputForm];
        comppos=spd[[1]];(* Print[ spd]; *)
        Write[fileid,Length[comppos]];
        xy=spd[[2]];
        comppos=Append[comppos,{Length[xy],Length[xy]}];
        edge=spd[[3]];
        crossing=spd[[4]];
        com=Length[comppos];
        len=Length[crossing];
        k=k0=0;
        For[i=1,i<com,i++,
            m=comppos[[i,1]]; n=comppos[[i+1,1]];
            For[j=1,j\[LessEqual]len,j++,
                under=crossing[[j,1]];
                  overcr=crossing[[j,2]];
                  If[m\[LessEqual]under && under<n,k++];
                If[m\[LessEqual]overcr && overcr<n, k++]
                ];
      nump=Append[nump,(k-k0)/2];
      k0=k;
            Write[fileid,k]
            ];
        For[i=1,i\[LessEqual]Length[edge],i++,
                 m=edge[[i,1]]; n=edge[[i,2]];
                 For[j=1,j\[LessEqual]len,j++,
                      
        If[crossing[[j,1]]\[Equal]m,
          cpinfo=Append[cpinfo,{{m,n},{crossing[[j,1]],crossing[[j,2]]}}];
          (* {m,n}: edge, {crossing[[j,1]],crossing[[j,2]]}: corssing,
            if m==crossing[[j,1]], then over crossing *)
                
          If[m==crossing[[j,1]],cpsign=Append[cpsign,1],
              cpsign=Append[cpsign,0]];
                            p1=xy[[m+1]]; p2=xy[[n+1]];
                            p3=xy[[crossing[[j,2]]+1]];
                            p4=xy[[NextPt[crossing[[j,2]],com,comppos]+1]];
                            cp=CrossingPoint[p1,p2,p3,p4];cp=Round[cp];
                
          If[Length[cp]!=0, cplist=Append[cplist,{-i,cp}],Close[fileid];
            Return["fail to convert."]]
                      ];
                    
        If[crossing[[j,2]]\[Equal]m,
          cpinfo=Append[cpinfo,{{m,n},{crossing[[j,1]],crossing[[j,2]]}}];
              
          If[m==crossing[[j,1]],cpsign=Append[cpsign,1],
            cpsign=Append[cpsign,0]];
                         p1=xy[[m+1]];
                         p2=xy[[n+1]];
                         p3=xy[[crossing[[j,1]]+1]];
                         p4=xy[[NextPt[crossing[[j,1]],com,comppos]+1]];
                         cp=CrossingPoint[p1,p2,p3,p4];cp=Round[cp];
                         
          If[Length[cp]!=0, cplist=Append[cplist,{i,cp}],Close[fileid];
            Return["fail to convert."]]
                      ];
                  ];
            ];
           cp=FindDistance[xy,cplist,cpinfo];
      cplist=cp[[1]];cpinfo=cp[[2]];(* Print[cplist];Print[cpinfo]; *)
           For[i=1,i<com,i++,
                 xy=Insert[xy,xy[[comppos[[i,1]]+i]],comppos[[i+1,1]]+i]
            ];
          Write[fileid,Length[xy]];
          For[i=1,i\[LessEqual]Length[xy],i++,
                Write[fileid,xy[[i,1]]," ",xy[[i,2]]]
            ];
    For[i=1,i\[LessEqual]Length[crossing],i++,
                Write[fileid,crossing[[i,2]]," ",crossing[[i,1]]]
            ];
    (* over or under information of crossing point: 1 => under, 0 => over *)
          For[i=1,i\[LessEqual]Length[cplist],i++,
      If[cplist[[i,1]]>0,Write[fileid,1], Write[fileid,0]]
            ];
        Write[fileid,555];
        Close[fileid];
    
    For[i=1,i\[LessEqual]Length[cplist],i++,
      For[j=1,j\[LessEqual]Length[cplist],j++,
        If[i != j,
          ex=cplist[[i,2]];ex1=cplist[[j,2]];
          If[ex[[1]]==ex1[[1]] && ex[[2]]==ex1[[2]],pdataa=Append[pdataa,j];
            
            If[cplist[[i,1]]>0,k=cpinfo[[i]][[2,1]]+1,
              k=cpinfo[[i]][[2,2]]+1];
            
            under=CrossSign[spd[[2,cpinfo[[i]][[1,1]]+1]],
                spd[[2,cpinfo[[i]][[1,2]]+1]],spd[[2,k]]];
            
            If[cplist[[i,1]]>0, 
              If[under==True,pdatab=Append[pdatab,2],pdatab=Append[pdatab,4]],
              If[under==True,pdatab=Append[pdatab,3],
                pdatab=Append[pdatab,1]]]
            ]
          ]
              ]
      ];
    For[i=1,i\[LessEqual]Length[pdataa],i++, 
      If[pdatab[[i]]==2,pdata=Append[pdata,-pdataa[[i]]]];
      If[pdatab[[i]]==4,pdata=Append[pdata,pdataa[[i]]] ]     
      ];
    Print["The corresponding p-data:"];
    Print[{nump,pdata}];
        (* Print[
          "Outputted to PLFromSnappea.sp which is a data file of the function GetPdatabyTracking[]."]\
; *)
        Return[True]
        ]
CheckIntersection[p1_,p2_,p3_,p4_]:=Block[{f1,f2},
    f1=(p2[[2]]-p1[[2]])*p3[[1]]+(p1[[1]]-p2[[1]])*
          p3[[2]]-(p1[[1]]*p2[[2]]-p2[[1]]*p1[[2]]);
    f2= (p2[[2]]-p1[[2]])*p4[[1]]+(p1[[1]]-p2[[1]])*
          p4[[2]]-(p1[[1]]*p2[[2]]-p2[[1]]*p1[[2]]);
    If[f1*f2<0,
      Return[CrossingPoint[p1,p2,p3,p4]],{}]
    ]

GetCrossingSequence[xy_,crossnum_]:=
  Block[{i,j,k,l,n1,n2,com,len,cr,crossing={}},
    len=Length[xy]; (* without the duplicate of coordinates *)
    com=Length[crossnum];
    For[i=1,i\[LessEqual]len,i++,
      For[j=1,j\[LessEqual]len,j++,
        If[i\[NotEqual]j,
          l=1;n1=i+1;
          For[k=1,k\[LessEqual]com,k++,
            If[i\[Equal]crossnum[[k]],n1=l;Break[]];
            l=crossnum[[k]]+1];
          l=1;n2=j+1;
          For[k=1,k\[LessEqual]com,k++,
            If[j\[Equal]crossnum[[k]],n2=l;Break[]];
            l=crossnum[[k]]+1];
          cr=CheckIntersection[xy[[i]],xy[[n1]],xy[[j]],xy[[n2]]];
          If[cr\[NotEqual]{},crossing=Append[crossing,{i,cr}]]
          ]
        ]
      ];
    Return[crossing]
    ]

 SnapPeaDataFromPLData[fname_]:=
  Block[{i,j,k=0,sn,ex,len,com,crossnum={},compnumxy={},xy={},x,y,x0,y0,
      crossinginfo={},cplist={},snapinfo={},fileid},
        sn=OpenRead[fname];
        If[sn==$Failed,Print["Cannot open ",fname,"."];Return[]];
        com=Read[sn,Number];
        For[i=1,i\[LessEqual]com,i++,
            crossnum=Append[crossnum,Read[sn,Number]];
            (* crossing numbers of each component. *)
            ];
        len=Read[sn,Number];
        x0=Read[sn,Number]; y0=Read[sn,Number];
        xy=Append[xy,{x0,y0}]; k++;
        For[i=3,i\[LessEqual]2*len,i+=2,
            x=Read[sn,Number]; y=Read[sn,Number];
            If[x!=x0 || y!=y0,xy=Append[xy,{x,y}]; k++];
            If[x\[Equal]x0 && y\[Equal]y0,compnumxy=Append[compnumxy,k];
                If[2*len-1\[LessEqual]i,Break[]];
                x0=Read[sn,Number]; y0=Read[sn,Number];
                xy=Append[xy,{x0,y0}]; i+=2; k++;
                ]
            ];
        For[i=1,i\[LessEqual]crossnum[[com]]/2,i++,
            ex={Read[sn,Number],Read[sn,Number]};
            cplist=Append[cplist,ex];
            ];
        For[i=1,i\[LessEqual]crossnum[[com]],i++,
            crossinginfo=Append[crossinginfo,Read[sn,Number]]
            ];
        Close[sn];
     
        snapinfo={};
        For[i=1,i<=crossnum[[com]]/2,i++,
            snapinfo=Append[snapinfo,{cplist[[i,2]],cplist[[i,1]]}]
            ];
        len=Length[xy];
        fileid=OpenWrite["SnappeaFromPL.pl",FormatType\[Rule]OutputForm];
        Write[fileid,"% Link Projection by K2K programmed by M.Ochiai"];
        Write[fileid,com];
        Write[fileid,0," ",0];
        For[i=1,i<com,i++,
            Write[fileid,compnumxy[[i]]," ",compnumxy[[i]]]
            ];
        Write[fileid,len];
        For[i=1,i\[LessEqual]len,i++,
            Write[fileid,xy[[i,1]]," ",xy[[i,2]]]];
        Write[fileid,len];
        j=1; k=0;
        For[i=1,i\[LessEqual]len,i++,
            
      If[i==compnumxy[[j]],Write[fileid,i-1," ",k];k=compnumxy[[j]]; j++, 
          Write[fileid,i-1," ",i]];
            ];
        len=Length[snapinfo];
        Write[fileid,len];
        For[i=1,i\[LessEqual]len,i++,
             Write[fileid,snapinfo[[i,1]]," ",snapinfo[[i,2]]]
            ];
        Write[fileid,-1];
        Close[fileid];
        
        Print[
      "Outputted to SnappeaFromPL.pl which must been only used in J. Weeks's SnapPea."]\
;
        Return[True]
        ]





KnotbyGauseanFormFromFile[fname_]:=
  Block[{insn,outsn,len0=0,len1,ex0,ex1,ex,infile,outfile,retcode, link},
    insn=OpenRead[fname];
    If[insn==$Failed,Print["Can't open ",fname];Return[-2]];
    outsn=
      OpenWrite[fname<>".gf",FormatType\[Rule]OutputForm,
        PageWidth\[Rule]300];
    While[True,
      ex=Read[insn,String];
      If[ex\[Equal]EndOfFile,Break[]];
      ex=StringReplace[ex,")("\[Rule]"),("];
      ex=StringReplace[StringReplace[ex,"("\[Rule]"{"],")"\[Rule]"}"];
      ex0=ToExpression[ex]; ex1=Flatten[ex0];
      len1=Length[ex1]/2;
      If[len0\[Equal]0,len0=len1,
        If[len0\[NotEqual]len1,Print["Detect a different length data. ",ex0];
          Close[insn]; Close[outsn]; Return[-1]]];
      ex=StringReplace[
          StringReplace[StringReplace[ex,"{"\[Rule]""],"}"\[Rule]" "],
          ","\[Rule]" "];
      Write[outsn,ex];
      ];
    Write[outsn,555," ",555];
    Close[insn]; Close[outsn];
    infile=fname<>".gf";
    outfile=fname<>".prd";
    link=Install["./knotbygauseanform", LinkMode->Launch];
    retcode=KnotbyGauseanForm[len0,infile,outfile,{}];
    Uninstall[link];
    If[retcode\[NotEqual]1,Print["Fail to conversion."];Return[0],
      Print["Outputted to a p-data file: ",outfile];
      Return[True]]
    ]

KnotbyGauseanForm[ex_]:=Block[{i,k=2,len,ex1,pdata,pdata2={}, link},
    If[Not[ListQ[ex]] || StringQ[ex],
      Print["Please input a Gausean form of a knot such as ",{{1,4},{3,8},{5,
            10},{7,14},{9,2},{11,16},{13,20},{15,6},{17,22},{19,12},{21,
            18}}];
      Return[False]
      ];
     ex1=Flatten[ex];
    len=Length[ex1];
    pdata2=Table[0,{i,2*len}];
    For[i=1,i\[LessEqual]len,i+=2,
      If[Mod[ex1[[i]],2]\[Equal]0, pdata2[[k]]=ex1[[i]];k++,
        If[Mod[ex1[[i+1]],2]\[Equal]0, pdata2[[k]]=-ex1[[i+1]];k++]]
      ];
    len/=2;
    link=Install["./knotbygauseanform", LinkMode->Launch];
    pdata=KnotbyGauseanForm[len,"","",pdata2];
    Uninstall[link];
    Print[pdata]; 
    Return[True]
    ]

GauseanFormFromDT[dt_]:=Block[{i,len,gf={}},
    len=Length[dt];
    For[i=1,i\[LessEqual]len,i++,
      If[dt[[i]]>0,gf=Append[gf,{2*i-1,dt[[i]]}],
        gf=Append[gf,{-dt[[i]],2*i-1}]]];
    Return[gf]
    ]

KnotbyDT[ex_]:=Block[{i,len,pdata, link},
    len=Length[ex];
    pdata=Table[0,{i,2*len}];
    For[i=1,i\[LessEqual]len,i++,
      pdata[[i+1]]=-ex[[i]]
      ];
    link=Install["./knotbygauseanform", LinkMode->Launch];
    pdata=KnotbyGauseanForm[len,"","",pdata];
    Uninstall[link];
    Return[pdata]
    ]

KnotbyDowkerThistlethwaiteNotation[ex_]:=KnotbyDT[ex]

KnotbyDTFromFile[fname_]:=Block[{i,insn,len,ex,dtdata,pdata, link},
    insn=OpenRead[fname];
    If[insn==$Failed,Print["Can't open ",fname];Return[-2]];
    link=Install["./knotbygauseanform", LinkMode->Launch];
    dtdata=Table[0,{i,200}];
    While[True,
      ex=Read[insn,Number];
      If[ex\[Equal]EndOfFile,Break[]];
      len=ex;
      ex=Read[insn,Number]; (* ex: data number *)
      Print[ex];
      For[i=1,i\[LessEqual]len,i++,
        ex=Read[insn,Number];
        dtdata[[i+1]]=-ex
        ];
      pdata=KnotbyGauseanForm[len,"","",dtdata];
      Print[pdata];
      If[Not[ListQ[pdata]],
        Close[insn]; Return[False]]
      ];
    Uninstall[link];
    Close[insn];
    Return[True]
    ]

KnotInternalFormbyDTFromFileToFile[infname_,outfname_]:=
  Block[{i,k=-1,insn,outsn,len,ex,dtdata,pdata, link},
    insn=OpenRead[infname];
    If[insn==$Failed,Print["Can't open ",infname];Return[-2]];
    outsn=
      OpenWrite[outfname,FormatType\[Rule]OutputForm,PageWidth\[Rule]100];
    If[outsn==$Failed,Print["Can't open ",outfname];Return[-2]];
    link=Install["./knotbygauseanform", LinkMode->Launch];
    dtdata=Table[0,{i,200}];
    While[True,
      ex=Read[insn,Number];
      If[ex\[Equal]EndOfFile,Break[]];
      len=ex;
      ex=Read[insn,Number]; (* ex: data number *)
      If[k<100,Print[ex],If[Mod[k,1000]\[Equal]0,Print[k]]];
      For[i=1,i\[LessEqual]len,i++,
        ex=Read[insn,Number];
        dtdata[[i+1]]=-ex
        ];
      pdata=KnotbyGauseanForm[len,"","",dtdata];
      If[Not[ListQ[pdata]],Print[pdata];
        Close[insn]; Close[outsn];Return[False],k++;Write[outsn,pdata]]
      ];
    Uninstall[link];
    Write[outsn,555];
    Write[outsn,"Total data count = ",k];
    Close[insn]; Close[outsn];
    Print["Total data count = ",k];
    Return[True]
    ]

KnotbyDTFromFileToFile[infname_,outfname_]:=Block[{retcode, link},
    link=Install["./ExternalKnotbyGause", LinkMode->Launch];
    retcode=KnotbyGauseanForm[infname,outfname];
    Uninstall[link];
    Return[retcode]
    ]





$pdata=Table[0,{i,100}];
$updown=Table[0,{i,100}];
$headvisited=Table[0,{i,100}];
$startn=$jstart = 1; 
$linkcomponent=1;
$componentnum=Table[0,{i,100}];

StringLotate[str_]:=
  StringInsert[StringDrop[str,{1,1}],StringTake[str,1],StringLength[str]]

CheckFirst[str_]:=Block[{i,len,ch,str1=str},
    len=StringLength[str1];
    ch=StringTake[str1,1];
    For[i=1,ch!="a" && ch!="A" ,i++,
      If[len<i,Break[]];
      str1=StringLotate[str1];ch=StringTake[str1,1]];
    If[ch\[Equal]"a" || ch\[Equal]"A", Return[str1],Return[""]]]

SameListQ[lst1_,lst2_]:=
  If[lst1[[1]]\[Equal]lst2[[1]] && lst1[[2]]\[Equal]lst2[[2]],True,False]

FindCrossing[i_,len_,$pdata_]:=Block[{j},
    For[j=1,j\[LessEqual]2*len,j++,
      If[i\[NotEqual]j && SameListQ[$pdata[[i]],$pdata[[j]]],Return[j]]]]

DownStream[n_,i_,j_,bindex_,bnum_,len_,plat_]:=Block[{i1,k1,k2},
    (* n-th intersection point: i-th word; j-th generator *)
    If[n>2*len,Return[n]];
    If[n>$startn && i\[Equal]1 && j==$jstart,Return[n]];
    If[i\[Equal]1,$headvisited[[j]]++];
    $componentnum[[n]]=$linkcomponent;
    For[i1=i,i1\[LessEqual]len,i1++,
      If[j\[Equal]1,k1=0,k1=plat[[i1,j-1]]];
      k2=plat[[i1,j]];
      If[k1\[NotEqual]0 ,$pdata[[n]]={i1,j-1};$updown[[n]]={1,k1};
        If[i1\[Equal]len,
          
          If[EvenQ[j-1],Return[UpStream[n+1,len,j-2,bindex,bnum,len,plat]],
            Return[UpStream[n+1,len,j,bindex,bnum,len,plat]]],
          Return[DownStream[n+1,i1+1,j-1,bindex,bnum,len,plat]]]];
      If[k2\[NotEqual]0 ,$pdata[[n]]={i1,j};$updown[[n]]={2,k2};
        If[i1\[Equal]len,
          
          If[EvenQ[j+1],Return[UpStream[n+1,len,j,bindex,bnum,len,plat]],
            Return[UpStream[n+1,len,j+2,bindex,bnum,len,plat]]],
          Return[DownStream[n+1,i1+1,j+1,bindex,bnum,len,plat]]]];
      ];
    If[EvenQ[j],Return[UpStream[n,len,j-1,bindex,bnum,len,plat]],
      Return[UpStream[n,len,j+1,bindex,bnum,len,plat]]]]

UpStream[n_,i_,j_,bindex_,bnum_,len_,plat_]:=Block[{i1,k1,k2},
    If[n>2*len,Return[n]];
    $componentnum[[n]]=$linkcomponent;
    For[i1=i,1\[LessEqual]i1,i1--,
      If[j\[Equal]1,k1=0,k1=plat[[i1,j-1]]];
      k2=plat[[i1,j]];
      If[k1\[NotEqual]0 ,$pdata[[n]]={i1,j-1};$updown[[n]]={3,k1};
        If[i1\[Equal]1,
          If[EvenQ[j-1],
            $headvisited[[j-1]]++;
            Return[DownStream[n+1,1,j-2,bindex,bnum,len,plat]],
            $headvisited[[j-1]]++;
            Return[DownStream[n+1,1,j,bindex,bnum,len,plat]]],
          Return[UpStream[n+1,i1-1,j-1,bindex,bnum,len,plat]]]];
      If[k2\[NotEqual]0 ,$pdata[[n]]={i1,j};$updown[[n]]={4,k2};
        If[i1\[Equal]1,
          If[EvenQ[j+1],
            $headvisited[[j+1]]++;
            Return[DownStream[n+1,1,j,bindex,bnum,len,
                plat]],$headvisited[[j+1]]++;
            Return[DownStream[n+1,1,j+2,bindex,bnum,len,plat]]],
          Return[UpStream[n+1,i1-1,j+1,bindex,bnum,len,plat]]]];
      ];
    If[EvenQ[j],Return[DownStream[n,1,j-1,bindex,bnum,len,plat]],
      Return[DownStream[n,1,j+1,bindex,bnum,len,plat]]]]

CompNumInfo[len_,pd_]:=Block[{i,j,pos,s,nump={}},
    For[i=1,i\[LessEqual]2*len,i++,
      pos=pd[[i]];
      If[$componentnum[[i]]\[NotEqual]0,$componentnum[[pos]]=0]
      ];
    For[j=1,j<=$linkcomponent,j++,
      s=0;
      For[i=1,i\[LessEqual]2*len,i++,
        If[$componentnum[[i]]\[Equal]j,s++]];
      nump=Append[nump,s]
      ];
    Return[nump]
    ]

CrossingInfo[len_,pd_]:=Block[{i,pos,pi,pj},
    For[i=1,i\[LessEqual]2*len,i++,
      pos=pd[[i]]; 
      pi=$updown[[i]][[1]]; 
      pj=$updown[[pos]][[1]];
      If[pi\[Equal]1  && pj\[Equal]2,
        If[$updown[[i]][[2]]>0,$pdata[[i]]=2, $pdata[[i]] = 3]];
      If[pi\[Equal]2  && pj\[Equal]1,
        If[$updown[[i]][[2]]>0,$pdata[[i]]=1, $pdata[[i]] =4]];
      If[pi\[Equal]2  && pj\[Equal]4,
        If[$updown[[i]][[2]]>0,$pdata[[i]]=3, $pdata[[i]] = 2]];
      If[pi\[Equal]4  && pj\[Equal]2,
        If[$updown[[i]][[2]]>0,$pdata[[i]]=4, $pdata[[i]] = 1]];
      If[pi\[Equal]1  && pj\[Equal]3,
        If[$updown[[i]][[2]]>0,$pdata[[i]]=4, $pdata[[i]] = 1]];
      If[pi\[Equal]3  && pj\[Equal]1,
        If[$updown[[i]][[2]]>0,$pdata[[i]]=3, $pdata[[i]] = 2]];
      If[pi\[Equal]3  && pj\[Equal]4,
        If[$updown[[i]][[2]]>0,$pdata[[i]]=1, $pdata[[i]] = 4]];
      If[pi\[Equal]4  && pj\[Equal]3,
        If[$updown[[i]][[2]]>0,$pdata[[i]]=2, $pdata[[i]] = 3]]]]

KnotFromPlat[str_]:=Block[{i,j,len,bnum,bindex,plat,pd,knot,nump},
    len=StringLength[str];
    For[i=1,i\[LessEqual]2*len,
      i++,$headvisited[[i]]=$pdata[[i]]=$componentnum[[i]]=0];
    pd=Table[0,{i,2*len}];
    bnum=bwdtonumwd[str];
    bindex=Max[Map[(Abs[#])&,bnum]]+1;
    If[Mod[bindex,2]\[Equal]1,
      Print[
        "Wrong data !!! (All braids must have even strings for plat closure.)"]\
;Return[str]];
    plat=Table[0,{i,len},{j,bindex}];
    For[i=1,i\[LessEqual]len,i++,plat[[i,Abs[bnum[[i]]]]]=bnum[[i]]];
    $startn=$jstart=1;$linkcomponent=1;
    While[True,
      $startn=DownStream[$startn,1,$jstart,bindex,bnum,len,plat];
      If[$startn>2*len,Break[]];
      For[i=1,i\[LessEqual]len,i++,
        If[$headvisited[[i]]==0,$jstart=i;$linkcomponent++;Break[]]]
      ];
    For[i=1,i\[LessEqual]2*len,i++,pd[[i]]=FindCrossing[i,len,$pdata]];
    nump=CompNumInfo[len,pd];
    CrossingInfo[len,pd];
    knot={};
    For[i=1,i\[LessEqual]2*len,i++,
      If[$pdata[[i]]==1,knot=Append[knot,-pd[[i]]]];
      If[$pdata[[i]]==3,knot=Append[knot,pd[[i]]]]];
    Return[{nump,knot}]]






TangleResolution[type_]:=Block[{ret, link},
    link=Install["./kicktangle", LinkMode->Launch];
    ret=kicktangleknot[type];
    Uninstall[link];
    If[First[ret]\[Equal]1,
      Return[{{ret[[2]],ToExpression[ret[[4]]]},{ret[[3]],
            ToExpression[ret[[5]]]}}],Print[ret[[4]]]]
    ]

HOMFLYbyTangleDecomposition[t1_List,t2_List]:=Block[{a1,a2,b1,b2,x,y},
    a1=t1[[1,2]];b1=t1[[2,2]];
    a2=t2[[1,2]];b2=t2[[2,2]];
    If[t1[[1,1]]\[Equal]0 && t2[[1,1]]\[Equal]0, 
      Return[Simplify[a1*a2*(x+y)+a1*b2+b1*a2+b1*b2*(1/x-y(x+y)/x)]]];
    If[t1[[1,1]]\[Equal]0 && t2[[1,1]]\[Equal]4, 
      Return[Simplify[a1*a2+a1*b2*(x+y)+b1*a2*(1/x-y(x+y)/x)+b1*b2]]];
    If[t1[[1,1]]\[Equal]1 && t2[[1,1]]\[Equal]1, 
      Return[Simplify[a1*a2*(x+y)+a1*b2+b1*a2+b1*b2*(x+y)]]];
    If[t1[[1,1]]\[Equal]1 && t2[[1,1]]\[Equal]3, 
      Return[Simplify[a1*a2+a1*b2*(x+y)+b1*a2*(x+y)+b1*b2]]];
    If[t1[[1,1]]\[Equal]2 && t2[[1,1]]\[Equal]2, 
      Return[Simplify[a1*a2*(x+y)+a1*b2+b1*a2+b1*b2*(1/x-y(x+y)/x)]]];
    If[t1[[1,1]]\[Equal]2 && t2[[1,1]]\[Equal]5, 
      Return[Simplify[a1*a2+a1*b2*(x+y)+b1*a2*(x+y)+b1*b2]]];
    If[t1[[1,1]]\[Equal]3 && t2[[1,1]]\[Equal]3, 
      Return[Simplify[a1*a2*(x+y)+a1*b2+b1*a2+b1*b2*(x+y)]]];
    If[t1[[1,1]]\[Equal]3 && t2[[1,1]]\[Equal]1, 
      Return[Simplify[a1*a2+a1*b2*(x+y)+b1*a2*(x+y)+b1*b2]]];
    If[t1[[1,1]]\[Equal]4 && t2[[1,1]]\[Equal]4, 
      Return[Simplify[a1*a2*(1/x-y(x+y)/x)+a1*b2+b1*a2+b1*b2*(x+y)]]];
    If[t1[[1,1]]\[Equal]4 && t2[[1,1]]\[Equal]0, 
      Return[Simplify[a1*a2+a1*b2*(1/x-y(x+y)/x)+b1*a2*(x+y)+b1*b2]]];
    If[t1[[1,1]]\[Equal]5 && t2[[1,1]]\[Equal]5, 
      Return[Simplify[a1*a2*(1/x-y(x+y)/x)+a1*b2+b1*a2+b1*b2*(x+y)]]];
    If[t1[[1,1]]\[Equal]5 && t2[[1,1]]\[Equal]2, 
      Return[Simplify[a1*a2+a1*b2*(1/x-y(x+y)/x)+b1*a2*(x+y)+b1*b2]]];
    Print["Undefined tangle decomposition"]]

End[]

EndPackage[]